# 筆記-資料密集型應用系設計

## 可靠性/可擴展性/可維護性

- p.15 在高百分位數的區段，影響回應時間的大多數原因來自於排隊。 因為CPU並行處理能力的上限，只要有少量慢請求產生，後續請求就會被擋住，此現象稱為隊頭阻塞(head-of-line blocking)


## 資料模型與查詢語言

- p.39 多對一和多對多關係，relational model比document model的支援更佳。
在多對多的情況下，對document model發出多次請求可以模擬類似join的效果，但通常會使應用程式變複雜，需要處理反規則化導致的重複資料一致性問題，以及使性能更差。

- p.43 宣告式語言（e.g. SQL, 只需描述想要的結果，不像命令式需描述如何實現) 通常用於平行執行，現今加快計算處理速度通常是透過增加CPU核心，而不是拉高時脈。資料庫都傾向採用平行方式來實現查詢語言

- p.46, p.48 一些NoSQL支援MapReduce（宣告式和命令式的混合的程式設計模型，宣告式的型態，命令式的實作。
Map處理數據輸入，生成key value pair/Reduce針對各個key進行aggregate或其他處理，兩者皆必須是pure functions，不執行額外Db查詢），以此執行跨機器叢集的查詢

## 資料儲存與檢索

- p.90 in-memory databases相較於基於磁碟的儲存引擎，其性能優不是因為它們不需要從磁碟讀取資料。
  只要記憶體充足，作業系統會將最近使用到的資料快取在記憶體中，所以就算基於磁碟，後者也很可能很少需要從磁碟來讀取資料。
  In-memory databases之所以快，主要是因為它們**省去了將in-memory資料結構編碼成可寫入磁碟的格式**的這段行為

- 摘要SSTable/LSM Trees v.s. B Tree

| 特性               | Hash Index                                 | SSTable & LSM Trees                                | B-Tree                                           |
|--------------------|--------------------------------------------|---------------------------------------------------|--------------------------------------------------|
| **基本概念**       | 基於哈希函數將鍵值映射到特定桶（Bucket）      | 使用多層排序的字符串表（SSTable）與日誌結構合併樹（LSM Trees） | 自平衡的有序樹形結構                              |
| **結構**           | 哈希桶結構，可能包含鏈表或其他碰撞處理機制    | 多層有序文件，內存中的 MemTable 與磁碟上的 SSTables | 節點包含多個鍵值和指向子節點的指標，所有葉子在同一層 |
| **查詢類型**       | 僅支援等值查詢                             | 支援等值查詢，範圍查詢需額外處理                   | 支援等值查詢和範圍查詢                           |
| **查詢性能**       | 接近 O(1)，極速的精確匹配查詢               | 讀取可能需要檢查多個 SSTables，但可透過 Bloom Filter 等優化 | O(log n)，穩定且高效的查詢性能                   |
| **寫入性能**       | 寫入速度快，但處理碰撞可能影響性能           | 高寫入性能，寫入集中於 MemTable，後續批次寫入 SSTables | 每次寫入需即時更新樹結構，寫入性能較低             |
| **範圍查詢支援**   | 不支援範圍查詢                             | 支援範圍查詢，但較為複雜                           | 原生支援範圍查詢                                 |
| **資料順序**       | 鍵值無序                                   | 資料在每個 SSTable 中有序                           | 鍵值有序排列                                     |
| **碰撞處理**       | 需要處理哈希碰撞（如鏈表、開放定址等）      | 無需處理哈希碰撞，資料有序存儲                       | 無需處理哈希碰撞，通過有序結構管理鍵值             |
| **維護操作**       | 不需特別維護，但哈希函數需良好分佈           | 定期進行 Compaction 合併 SSTables                 | 定期進行 VACUUM 和 ANALYZE 以維持索引效率        |
| **適用場景**       | 高頻次的精確查詢，且不需要範圍查詢          | 高寫入負載、大規模資料儲存、分散式系統             | 通用查詢需求，尤其是需要範圍查詢的應用           |
| **常見應用**       | - 記憶體中的 Hash Table（如 Python 字典、Java HashMap）<br>- NoSQL 資料庫（如 Redis）<br>- 分散式系統中的一致性哈希（如 Amazon DynamoDB） | - Apache Cassandra<br>- LevelDB & RocksDB<br>- Google Bigtable | - 關聯式資料庫（如 PostgreSQL、MySQL 的 InnoDB 引擎）<br>- 檔案系統（如 NTFS、HFS+）<br>- SQLite |
| **資料一致性**     | 通常為強一致性，但依實作而定               | 最終一致性（可配置）                                | 強一致性                                         |
| **優點**           | - 極速的精確查詢<br>- 簡單的結構             | - 高寫入性能<br>- 適合批次處理和大規模資料          | - 支援多種查詢類型<br>- 穩定的查詢性能            |
| **缺點**           | - 不支援範圍查詢<br>- 可能存在哈希碰撞影響性能 | - 讀取時需檢查多個檔案，可能增加延遲               | - 寫入性能相對較低<br>- 結構較複雜                 |

## 詳細說明

### Hash Index
- **適用場景**：當應用需要頻繁進行精確查詢且不涉及範圍查詢時，Hash Index 是理想的選擇。例如，鍵值存儲系統和緩存系統（如 Redis）廣泛使用 Hash Index 來提升查詢速度。
- **優點**：查詢速度極快，接近 O(1) 的時間複雜度。
- **缺點**：不適用於範圍查詢，且需處理哈希碰撞。

### SSTable & LSM Trees
- **適用場景**：適合高寫入負載、大規模資料儲存和分散式系統。NoSQL 資料庫如 Apache Cassandra 和嵌入式資料庫如 LevelDB、RocksDB 都採用 LSM Trees 結構。
- **優點**：寫入性能優越，適合批次處理和持續寫入。
- **缺點**：讀取時可能需檢查多個 SSTables，增加查詢延遲，但可透過 Bloom Filter 等技術優化。

### B-Tree
- **適用場景**：廣泛應用於需要多種查詢類型的系統，如關聯式資料庫（PostgreSQL、MySQL）、檔案系統（NTFS、HFS+）等。
- **優點**：支援等值查詢和範圍查詢，具有穩定且高效的查詢性能。
- **缺點**：寫入性能相對較低，尤其在高寫入負載下可能成為瓶頸。

